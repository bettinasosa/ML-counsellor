import { NextRequest, NextResponse } from 'next/server';import { performance } from 'perf_hooks';import { z } from 'zod';import {ChatFormDataSchema} from "@/lib/schema/formData";import {ChatResponseSchema} from "@/lib/schema/messages";import {debugMessage, logTimestamp, sanitizeHeaderValue} from "@/utils/helpers";import {conversationController} from "@/controllers/conversation";let initialized = false;export async function POST(req: NextRequest) {    const apiStart = performance.now();    const measureTime = (label: string) => logTimestamp(label, apiStart);    if (!initialized) {        try {            await conversationController.initialize();            initialized = true;            console.log("🚀 ConversationController initialized");        } catch (error) {            console.error('Failed to initialize ConversationController', error);            return NextResponse.json({ error: 'Initialization failed' }, { status: 500 });        }    }    console.log("🚀 API route called");    try {        const formData = await req.formData();        const userId = formData.get('userId');        const { message, threadId, files } = ChatFormDataSchema.parse({            message: formData.get('message'),            threadId: formData.get('threadId') || undefined,            files: formData.getAll('file') || [],        });        if (!userId) {            return NextResponse.json({ error: 'User ID is required' }, { status: 400 });        }        console.log("📝 New Query:", message);        measureTime("User Input Received");        const debugData = sanitizeHeaderValue(            debugMessage("🚀 API route called", {                userId,                messageLength: message.length,                hasThreadId: !!threadId,                filesCount: files?.length || 0,                openaiKeySlice: process.env.OPENAI_API_KEY?.slice(0, 4) + "****",            })        );        let currentThreadId = threadId;        if (!currentThreadId) {            measureTime("Create Thread Start");            currentThreadId = await conversationController.createThread(message);            measureTime("Create Thread Complete");        }        if (files && files.length > 0) {            measureTime("File Upload Start");            await conversationController.uploadFiles(currentThreadId, files as File[]);            measureTime("File Upload Complete");        }        measureTime("Conversation Start");        const aiResponse = await conversationController.runConversation(currentThreadId, message);        measureTime("Conversation Complete");        // Periodically summarize the conversation (e.g., every 5 messages)        const messageCount = await conversationController.threadManager.getMessageCount(currentThreadId);        let summary = undefined;        if (messageCount % 5 === 0) {            measureTime("Summarization Start");            summary = await conversationController.summarizeConversation(currentThreadId);            measureTime("Summarization Complete");        }        const chatResponse = ChatResponseSchema.parse({            aiResponse,            threadId: currentThreadId,            summary,        });        const apiResponse = NextResponse.json(chatResponse, { status: 200 });        apiResponse.headers.set("X-Debug-Data", debugData);        measureTime("API Complete");        return apiResponse;    } catch (error) {        console.error("💥 An error occurred while processing the request", error);        if (error instanceof z.ZodError) {            return NextResponse.json({ error: 'Invalid input format', details: error.errors }, { status: 400 });        }        const errorResponse = ChatResponseSchema.parse({            aiResponse: {                text: "Sorry, I couldn't process your request. Please try again later.",                thinking: "Error occurred when processing the request.",                user_mood: "neutral",                suggested_questions: [],                coping_strategies: [],                debug: { context_used: false, identified_issue: "Error processing request" },                redirect_to_human: { should_redirect: false },            },            threadId: "error",            summary: undefined,        });        return NextResponse.json(errorResponse, { status: 500 });    }}