import AssistantService from "@/services/assistant";import ThreadManager from "@/services/threadManager";import FileHandler from "@/services/fileHandler";import {AssistantMessage} from "@/lib/schema/messages";import {openAIClient} from "@/lib/openaiClient";import Logger from "@/utils/logger";import {delay, sanitizeAndParseJSON} from "@/utils/helpers";import {SUMMARY_PROMPT} from "@/lib/prompts/summary";import path from "node:path";import os from "os";import * as fs from "node:fs";import VectorStore from "@/services/vectorStore";class ConversationController {    private assistantService: AssistantService;    private vectorStore: VectorStore;    threadManager: ThreadManager;    private fileHandler: FileHandler | undefined;    private vectorStoreId: string | null = null;    private assistantId: string | null = null;    constructor() {        this.assistantService = new AssistantService();        this.vectorStore = new VectorStore();        this.threadManager = new ThreadManager();    }    async initialize() {        try {            this.assistantId = await this.assistantService.getOrCreateAssistant();            this.vectorStoreId = await this.vectorStore.getOrCreateVectorStore();            await this.vectorStore.attachToAssistant(this.assistantId!);            this.fileHandler = new FileHandler(this.vectorStoreId!);            Logger.log('ConversationController initialized successfully');        } catch (error) {            Logger.error('Failed to initialize ConversationController', error);            throw error;        }    }    async createThread(initialMessage: string): Promise<string> {        if (!this.vectorStoreId) {            throw new Error('Vector store not initialized');        }        return await this.threadManager.createThread(initialMessage, this.vectorStoreId);    }    async uploadFiles(files: File[]): Promise<string[] | undefined> {        return this.fileHandler?.uploadFiles(files);    }    async runConversation(threadId: string, userMessage: string): Promise<AssistantMessage> {        try {            await this.threadManager.addMessage(threadId, 'user', userMessage);            // Create and poll run            const run = await this.createRun(threadId);            const runStatus = await this.pollRunStatus(threadId, run.id);            // Retrieve messages            const messages = await this.threadManager.getMessages(threadId, run.id);            const lastMessage = messages.pop();            if (lastMessage && lastMessage.content[0].type === 'text') {                const { text } = lastMessage.content[0];                const { annotations } = text;                const citations: string[] = [];                let index = 0;                for (let annotation of annotations) {                    text.value = text.value.replace(annotation.text, `[${index}]`);                    const { file_citation } = annotation;                    if (file_citation) {                        const citedFile = await openAIClient.client.files.retrieve(file_citation.file_id);                        citations.push(`[${index}] ${citedFile.filename}`);                        index++;                    }                }                Logger.log(`AI Response: ${text.value}`);                Logger.log(`Citations:\n${citations.join('\n')}`);            }            // Process AI response            const aiResponseContent = lastMessage?.content[0].text.value || '';            // const sanitizedResponse = sanitizeAndParseJSON(aiResponseContent);            const processedResponse = this.processAIResponse(aiResponseContent);            // Save to vector store            await this.fileHandler!.saveToVectorStore(threadId, processedResponse);            return processedResponse;        } catch (error) {            Logger.error('Failed to run conversation', error);            throw error;        }    }    private async createRun(threadId: string) {        try {            const run = await openAIClient.client.beta.threads.runs.createAndPoll(threadId, {                assistant_id: this.assistantId!,            });            Logger.log(`Run created with ID: ${run.id} for thread: ${threadId}`);            return run;        } catch (error) {            Logger.error('Failed to create run', error);            throw new Error('Unable to create run');        }    }    private async pollRunStatus(threadId: string, runId: string): Promise<any> {        try {            let runStatus = await openAIClient.client.beta.threads.runs.retrieve(threadId, runId);            while (runStatus.status !== 'completed') {                Logger.log(`Run ${runId} status: ${runStatus.status}`);                await delay(1000);                runStatus = await openAIClient.client.beta.threads.runs.retrieve(threadId, runId);            }            Logger.log(`Run ${runId} completed`);            return runStatus;        } catch (error) {            Logger.error(`Failed to poll run status for run ${runId}`, error);            throw new Error('Error while polling run status');        }    }    private processAIResponse(responseContent: string): AssistantMessage {        try {            const parsedResponse = JSON.parse(responseContent);            return {                role: 'assistant',                thinking: parsedResponse.thinking || '',                text: parsedResponse.text || '',                user_mood: parsedResponse.user_mood || 'neutral',                suggested_questions: parsedResponse.suggested_questions || [],                coping_strategies: parsedResponse.coping_strategies || [],                debug: {                    context_used: parsedResponse.debug?.context_used || false,                    identified_issue: parsedResponse.debug?.identified_issue || '',                },                redirect_to_human: parsedResponse.redirect_to_human || {                    should_redirect: false,                },            };        } catch (error) {            Logger.error('Failed to process AI response', error);            throw new Error('Invalid AI response format');        }    }    async summarizeConversation(threadId: string): Promise<string> {        try {            const messages = await this.threadManager.getMessages(threadId);            const conversationText = messages                .map((msg) => `${msg.role}: ${msg.content[0].text.value}`)                .join('\n');            const summary = await openAIClient.client.chat.completions.create({                model: 'gpt-4o-mini',                messages: [                    { role: 'system', content: SUMMARY_PROMPT },                    { role: 'user', content: conversationText },                ],                max_tokens: 300,            });            const content = summary.choices[0].message.content || '';            const summaryContent = JSON.stringify({                summary: content,                timestamp: Date.now(),                threadId: threadId,            });            const tempFilePath = path.join(os.tmpdir(), `summary_${threadId}_${Date.now()}.json`);            fs.writeFileSync(tempFilePath, summaryContent);            const summaryFile = await openAIClient.client.files.create({                file: fs.createReadStream(tempFilePath),                purpose: 'assistants',            });            await openAIClient.client.beta.vectorStores.files.create(this.vectorStoreId!, {                file_id: summaryFile.id,            });            fs.unlinkSync(tempFilePath);            Logger.log(`Summarized conversation and saved to vector store for thread ${threadId}`);            return content;        } catch (error) {            Logger.error('Failed to summarize conversation', error);            throw new Error('Unable to summarize conversation');        }    }    // TODO: Implement extractCategories and analyzeSentiment}export const conversationController = new ConversationController();